# .NET Malware Memory Analysis - Volatility Hunting Guide

## Overview

This guide provides comprehensive techniques for hunting .NET-based malware in memory dumps using the Volatility framework. It covers detection, analysis, and extraction of .NET assemblies, CLR artifacts, and malicious code execution patterns.

## Prerequisites

- Volatility Framework (2.x or 3.x)
- Windows memory dump (.mem, .raw, .vmem)
- Appropriate Windows profile
- .NET analysis tools (optional: dnSpy, ILSpy, PEiD)

## Initial Analysis Setup

### 1. Profile Identification
```bash
# Determine correct profile for memory dump
python vol.py -f memdump.mem imageinfo

# Use specific profile for better accuracy
python vol.py -f memdump.mem --profile=Win10x64_18362 pslist
```

### 2. Process Overview
```bash
# List all running processes
python vol.py -f memdump.mem --profile=Win10x64_18362 pslist

# Focus on .NET related processes
python vol.py -f memdump.mem --profile=Win10x64_18362 pslist | grep -E "(dotnet|mscor|clr|powershell|csc)"
```

## .NET Runtime Detection

### 1. Common .NET Processes
```bash
# Look for .NET runtime processes
python vol.py -f memdump.mem --profile=Win10x64_18362 pslist | grep -i -E "(dotnet|MSBuild|csc|vbc|RegAsm|RegSvcs|InstallUtil|MSBuild)"

# Check for PowerShell (often used with .NET)
python vol.py -f memdump.mem --profile=Win10x64_18362 pslist | grep -i powershell
```

### 2. CLR Analysis
```bash
# Extract CLR modules from suspicious processes
python vol.py -f memdump.mem --profile=Win10x64_18362 dllist -p [PID] | grep -i -E "(mscor|clr|system\.|microsoft\.)"

# Check for .NET GAC assemblies
python vol.py -f memdump.mem --profile=Win10x64_18362 dllist -p [PID] | grep -i "GAC"
```

## .NET Assembly Extraction

### 1. Memory Dump Extraction
```bash
# Extract process memory for detailed analysis
python vol.py -f memdump.mem --profile=Win10x64_18362 procdump -p [PID] --dump-dir ./extracted/

# Extract specific memory segments
python vol.py -f memdump.mem --profile=Win10x64_18362 memmap -p [PID]
python vol.py -f memdump.mem --profile=Win10x64_18362 memdump -p [PID] -D ./extracted/
```

### 2. .NET Assembly Search
```bash
# Search for PE headers in memory (potential assemblies)
python vol.py -f memdump.mem --profile=Win10x64_18362 yarascan -Y "{ 4D 5A [2] 00 00 }" --pid=[PID]

# Search for .NET metadata headers
python vol.py -f memdump.mem --profile=Win10x64_18362 yarascan -Y "{ 42 53 4A 42 }" --pid=[PID]

# Look for Common Language Runtime signatures
python vol.py -f memdump.mem --profile=Win10x64_18362 yarascan -Y "{ 00 00 02 00 00 00 00 00 C0 00 00 00 00 00 00 46 }" --pid=[PID]
```

## Malware Detection Techniques

### 1. Process Hollowing Detection
```bash
# Check for process hollowing indicators
python vol.py -f memdump.mem --profile=Win10x64_18362 hollowfind

# Compare process path with loaded modules
python vol.py -f memdump.mem --profile=Win10x64_18362 pslist -v
python vol.py -f memdump.mem --profile=Win10x64_18362 dlllist -p [PID]
```

### 2. Suspicious Process Analysis
```bash
# Check process command lines for obfuscation
python vol.py -f memdump.mem --profile=Win10x64_18362 cmdline -p [PID]

# Look for base64 encoded payloads
python vol.py -f memdump.mem --profile=Win10x64_18362 cmdline | grep -i -E "(frombase64|encodedcommand)"

# Check for PowerShell execution policy bypass
python vol.py -f memdump.mem --profile=Win10x64_18362 cmdline | grep -i -E "(bypass|unrestricted|remotesigned)"
```

### 3. .NET Obfuscation Detection
```bash
# Search for common .NET obfuscators signatures
python vol.py -f memdump.mem --profile=Win10x64_18362 yarascan -Y "{ 00 00 00 00 FF FF FF FF 01 00 00 00 }" --pid=[PID]

# Look for encrypted strings patterns
python vol.py -f memdump.mem --profile=Win10x64_18362 strings -s 3 | grep -E "([A-Za-z0-9+/]{40,}={0,2})"
```

## Network Artifacts Analysis

### 1. Network Connections
```bash
# Check active network connections
python vol.py -f memdump.mem --profile=Win10x64_18362 netscan

# Filter connections by suspicious processes
python vol.py -f memdump.mem --profile=Win10x64_18362 netscan | grep [PID]

# Look for connections to non-standard ports
python vol.py -f memdump.mem --profile=Win10x64_18362 netscan | grep -v -E "(80|443|53|21|22|25)"
```

### 2. DNS Analysis
```bash
# Extract DNS queries
python vol.py -f memdump.mem --profile=Win10x64_18362 dnshistory

# Look for suspicious domains
python vol.py -f memdump.mem --profile=Win10x64_18362 dnshistory | grep -v -E "(microsoft|windows|google)"
```

## Registry Analysis for .NET Persistence

### 1. .NET Configuration
```bash
# Check .NET Framework configuration
python vol.py -f memdump.mem --profile=Win10x64_18362 printkey -K "SOFTWARE\Microsoft\.NETFramework"

# Look for suspicious .NET applications in startup
python vol.py -f memdump.mem --profile=Win10x64_18362 printkey -K "SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
```

### 2. CLR Settings
```bash
# Check CLR security settings
python vol.py -f memdump.mem --profile=Win10x64_18362 printkey -K "SOFTWARE\Microsoft\.NETFramework\Security"

# Look for assembly binding redirects
python vol.py -f memdump.mem --profile=Win10x64_18362 printkey -K "SOFTWARE\Microsoft\.NETFramework\AssemblyFolders"
```

## Advanced .NET Malware Analysis

### 1. Assembly Loading Analysis
```bash
# Extract assembly loading events from memory
python vol.py -f memdump.mem --profile=Win10x64_18362 handles -p [PID] -t File | grep -i ".dll"

# Check for dynamically loaded assemblies
python vol.py -f memdump.mem --profile=Win10x64_18362 handles -p [PID] -t Section
```

### 2. JIT Code Analysis
```bash
# Look for JIT compiled code sections
python vol.py -f memdump.mem --profile=Win10x64_18362 vadinfo -p [PID] | grep -E "(EXECUTE|READWRITE)"

# Extract JIT code regions
python vol.py -f memdump.mem --profile=Win10x64_18362 vaddump -p [PID] --base=[ADDRESS] -D ./jit_code/
```

### 3. Reflection and Dynamic Loading
```bash
# Search for reflection usage patterns
python vol.py -f memdump.mem --profile=Win10x64_18362 yarascan -Y "System.Reflection" --pid=[PID]

# Look for Assembly.Load* patterns
python vol.py -f memdump.mem --profile=Win10x64_18362 yarascan -Y "Assembly.Load" --pid=[PID]
```

## Common .NET Malware Families Detection

### 1. PowerShell-based .NET Malware
```bash
# Look for PowerShell .NET type loading
python vol.py -f memdump.mem --profile=Win10x64_18362 cmdline | grep -i "Add-Type"

# Check for in-memory .NET compilation
python vol.py -f memdump.mem --profile=Win10x64_18362 cmdline | grep -i "CompilerParameters"
```

### 2. Fileless .NET Malware
```bash
# Search for Base64 encoded assemblies
python vol.py -f memdump.mem --profile=Win10x64_18362 strings -s 100 | grep -E "^[A-Za-z0-9+/]{100,}={0,2}$"

# Look for gzip compressed payloads
python vol.py -f memdump.mem --profile=Win10x64_18362 yarascan -Y "{ 1F 8B 08 }" --pid=[PID]
```

### 3. .NET Injection Techniques
```bash
# Check for process injection indicators
python vol.py -f memdump.mem --profile=Win10x64_18362 malfind -p [PID]

# Look for VirtualAlloc/WriteProcessMemory patterns
python vol.py -f memdump.mem --profile=Win10x64_18362 apihooks -p [PID]
```

## Memory Strings Analysis

### 1. .NET String Extraction
```bash
# Extract Unicode strings (common in .NET)
python vol.py -f memdump.mem --profile=Win10x64_18362 strings -e u -s 3 > unicode_strings.txt

# Extract ASCII strings
python vol.py -f memdump.mem --profile=Win10x64_18362 strings -e a -s 3 > ascii_strings.txt

# Look for .NET-specific strings
grep -i -E "(system\.|microsoft\.|mscorlib|assembly|namespace)" unicode_strings.txt
```

### 2. Malicious String Patterns
```bash
# Search for common malware strings
grep -i -E "(download|execute|payload|shell|backdoor)" unicode_strings.txt

# Look for crypto/encoding patterns
grep -E "([A-Za-z0-9+/]{20,}={0,2})" unicode_strings.txt

# Find URL/IP patterns
grep -E "(http[s]?://|[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})" unicode_strings.txt
```

## Timeline Analysis

### 1. Process Timeline
```bash
# Create timeline of process creation
python vol.py -f memdump.mem --profile=Win10x64_18362 timeliner --output=body > timeline.body

# Process with mactime for better visualization
mactime -d -b timeline.body > timeline.csv
```

### 2. File Activity Timeline
```bash
# Check file access patterns
python vol.py -f memdump.mem --profile=Win10x64_18362 mftparser --output=body > file_timeline.body
```

## Reporting and Documentation

### 1. Evidence Collection
- **Process Information**: PID, PPID, command line, creation time
- **Assembly Details**: Name, version, location, signing status
- **Network Connections**: Remote IPs, ports, protocol
- **File Artifacts**: Created, modified, accessed files
- **Registry Changes**: Keys modified, values added

### 2. IOCs (Indicators of Compromise)
- Malicious file hashes (MD5, SHA1, SHA256)
- Network indicators (IPs, domains, URLs)
- Registry keys and values
- Mutexes and named objects
- Service names and descriptions

### 3. Technical Analysis Summary
```markdown
## .NET Malware Analysis Results

### Malware Classification
- **Family**: [Detected family name]
- **Type**: [Trojan/RAT/Loader/etc.]
- **Obfuscation**: [Yes/No - method used]

### Execution Method
- **Entry Point**: [How malware was executed]
- **Persistence**: [Mechanism used]
- **Privileges**: [Required/Escalated to]

### Capabilities
- **Network Communication**: [C2 servers, protocols]
- **Data Exfiltration**: [Methods, targets]
- **System Manipulation**: [Files, registry, processes]

### Recommendations
- **Immediate Actions**: [Containment steps]
- **Long-term**: [Prevention measures]
- **Monitoring**: [Detection rules]
```

## YARA Rules for .NET Malware

### 1. Generic .NET Assembly Rule
```yara
rule DotNet_Assembly
{
    meta:
        description = "Detects .NET assemblies in memory"
        author = "Threat Hunter"
        
    strings:
        $pe_header = { 4D 5A }
        $net_header = { 42 53 4A 42 }
        $clr_header = "mscoree.dll"
        
    condition:
        $pe_header at 0 and $net_header and $clr_header
}
```

### 2. Obfuscated .NET Rule
```yara
rule Obfuscated_DotNet
{
    meta:
        description = "Detects obfuscated .NET assemblies"
        
    strings:
        $s1 = "System.Reflection.Assembly"
        $s2 = "System.AppDomain"
        $s3 = "CreateInstance"
        $obf1 = { 00 00 00 00 FF FF FF FF }
        
    condition:
        all of ($s*) and $obf1
}
```

## Best Practices

1. **Always create a backup** of the memory dump before analysis
2. **Use multiple detection methods** - don't rely on a single technique
3. **Document everything** - commands used, results found, analysis steps
4. **Correlate findings** across different analysis techniques
5. **Validate results** by extracting and analyzing assemblies offline
6. **Keep tools updated** - new .NET versions may require updated signatures

## Tools Integration

### 1. External Tools
- **dnSpy**: .NET assembly editor and debugger
- **ILSpy**: .NET decompiler
- **PEiD**: Packer/obfuscator detection
- **HxD**: Hex editor for manual analysis

### 2. Automation Scripts
Consider creating scripts to automate common tasks:
- Batch string extraction and filtering
- Automatic IOC extraction
- Timeline correlation
- Report generation

This comprehensive guide provides the foundation for successful .NET malware hunting in memory dumps using Volatility, covering detection, analysis, and documentation aspects essential for thorough incident response.